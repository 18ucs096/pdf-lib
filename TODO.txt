Before 0.1.0 release:
* Document the current (low-level) API in a simple README
* Write some scripts/commands to handle the code building and release process.
* Add LICENSE!!!
* Add GitHub project tags

# Features
***** Create static "cm" members for operations like scaling, and translating *****
***** Export image dimensions from PNG and JPEG image factories *****
***** Add feature to bypass validations in prod builds! *****
***** Validate locations of text objects and operators! *****
***** Figure out how to publish flow types in NPM package *****
***** Make note of the dependency on "fontkit" and "unicode-properties" forks and suggest desire for better solution ****
***** Encode characters passed to "Tj" as code point hex codes, not string literals *****
***** Add credits for PNGImage and JPEGImage and font embedding *****
***** Consider forking png-js to avoid "Buffer" dependency *****
***** Make sure non-english character sets (any unicode character?) work correctly *****
***** Support page transfer between two different PDFs *****
***** Consider supporting saving as image using PDF-js *****
***** Consider using decorators (http://www.typescriptlang.org/docs/handbook/decorators.html)
      for argument validation, instead of manually typing out the validations *****
***** Flesh out TypeScript types for `fontkit` lib
***** Need to lint for unused imports *****
***** Investigate `pdfDoc.removePage` for `assets.pdfs.linearized_with_object_streams`,
      there might be a bug with removing first page or large numbers of pages?
***** Try changing imports for node-specific libraries in `fontkit` fork to avoid
      the need to browserify the whole module. Also investigate why it's necessary
      to do so in React Native, but not the browser? Maybe just need to ugligy
      (not browserify) it? *****

***** Remove index.js files from fork repos and publish to NPM *****
***** Update READMEs of fork repos with credits and workaround using browserify command *****

* Support PDFs with comments by stripping them before parsing.
* Support stream decompression for non FlateEncoded streams
* Add in "early stops" to parsers (like checking if first char is a "<", for hex strings) to avoid excessive work.
* Use "Length" dict entry when parsing streams
* (Maybe) Speed up parser by created a function that looks at the next input character to guess what PDF Object is next in the input bytes. (Will need to be able to access xref table because "Length" entries can be indirect references)
* Avoid parsing dicts twice (in case of parsing for stream before dict)
* Add credits file for the testing PDFs!
* Use XRef tables to parse the file on the fly instead of brute-force parsing it all in one go
* Set validation limits on pdf operator classes
* Create PDFRectangle structure!
* Remove all old dereference-reliant code...
* Make "lookup" type
* Support creation of PDFs as opposed to editing them
* Support annotations & links
* Support Acroform manipulation
* Support document outlines

# Tests:
* Create more "example-oriented" tests
* Consider using PDF.js to render documents in unit tests to avoid needing
  humans to run integration tests all the time. Can use jest-image-snapshot to
  compare them.
* Add more tests for "parseDocument" function. Need to test parsing on
 - updated documents
 - linearized documents
 - documents with object streams
 - etc...
* Write some more tests for "PDFParser" class as well.
* Add unit tests for:
 - core/pdf-document/*
 - core/pdf-parser/encoding/*
 - core/pdf-structures/factories/*
 - utils/*
* Add unit tests for simple and composite PDFOperator helpers

# Bugs
* See if "parseLinearization" is even necessary? It looks like the "linearization" section of a PDF might just be the same in structure as an update section, for example...
* See if the test-pdfs/pdf/dc/form/DC2210.pdf (& other linearized files in that dir: "grep -r "Linearized" .") should be parsed as linearized. Because they appear to have a linearization dict, but dont comply with the linearization spec.
* Figure out why the "2 0 R" object reference fails to be resolved in bol2.pdf
* Look into why pdfDoc.toBytes().length and pdfDoc.toBytesEfficient().length are different sizes... (some of this code was removed in commit: c508f73103021317580b641a6f895737e4e6e1b5)
* Update "parseTrailer" to handle files w/o "xref" and "trailer" keywords, as they are _not_ malformatted, but are to be expected in 1.5+ PDFs
* Maybe remove the "validKeys" stuff from PDFDictionaries?
* Make sure PDFDocument validates existence of its catalog
* Clean up "parseDocument" function
* Adding "TESTING" (using following non-embedded font) to "/Users/user/Desktop/pdf-lib/test-pdfs/pdf/ef/inst/ef_ins_1040.pdf"
  messes up the text within the "Caution" sections:
  ```
  pageFont.set(
    'F1',
    PDFDictionary.from({
      Type: PDFName.from('Font'),
      Subtype: PDFName.from('Type1'),
      BaseFont: PDFName.from('Times-Roman'),
    }),
  );
  ```
* !!When parsing PDFs with update sections, I don't think the PDFDocumentFactory.normalize function will respect object deletions, as it simply picks up the most recent version of each object...!!
